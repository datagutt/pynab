# Kaldi ASR Options for the Rust Port

## Current Python Implementation

- `nabd/asr.py` streams 16 kHz PCM frames into `KaldiNNet3OnlineDecoder` via the `py-kaldi-asr` bindings.
- Models live under `/opt/kaldi/model/` with locale-specific directories (for example `kaldi-nabaztag-fr-adapt-r20200203`).
- The decoder runs in a dedicated worker thread, receiving audio chunks and returning the best hypothesis on demand.
- Installation scripts fetch pre-built Kaldi bundles and ensure `py-kaldi-asr` wheel compatibility.

Any Rust replacement must preserve these runtime and deployment characteristics to remain drop-in compatible.

## Functional Expectations for a Rust ASR Layer

- Load Kaldi neural-network (TDNN/FST) models adapted for Nabaztag locales.
- Support incremental/streaming decoding from raw PCM buffers (16 kHz, mono).
- Offer low-latency partial/final hypotheses equivalent to `get_decoded_string`.
- Run under constrained ARM hardware (Raspberry Pi class) with minimal additional dependencies.
- Provide an ergonomic Rust API that integrates with the upcoming `nabd` rewrite plan (`docs/rust-implementation.md`).

## Compatibility with Current Nabaztag Models

- The existing artifacts generated by `asr/adapt-model.sh` (`kaldi-nabaztag-*-adapt-r*.tar.xz`) follow the online2 layout used by `py-kaldi-asr` (`model/final.mdl`, `model/graph/HCLG.fst`, speaker i-vectors, etc.).
- Vosk expects models to be repackaged with its template structure (`am/`, `graph/`, `conf/model.conf`, optional `ivector/`), and will not load a plain Kaldi GMM/online2 bundle without those adjustments.
- Action item: script the repackaging step so the adapted Nabaztag models can be transformed into Vosk-compatible bundles during the Rust migration.

## Candidate Rust Options

### 1. Vosk Safe Bindings (`vosk` crate)

- Mature Rust crate offering a safe wrapper over the Vosk offline recognizer, which itself builds on Kaldi components.
- Supports streaming recognition, custom grammars, speaker-independent and speaker-adapted models, and runs on Linux/ARM.
- Provides straightforward API surface:

```rust
use vosk::{Model, Recognizer};

let model = Model::new("/opt/pynab/vosk-model")?;
let mut recognizer = Recognizer::new(&model, 16_000.0)?;
recognizer.accept_waveform(&pcm_samples)?;
let result = recognizer.partial_result()?; // or final_result()
```

- Bundled examples demonstrate chunked decoding and grammar-constrained recognition.
- Models: existing Nabaztag Kaldi graphs may need conversion to Vosk's expected structure (HCLG + `conf`/dictionary). The `vosk-model-en` tooling can serve as a template for re-packaging adapted models.
- Distribution: Vosk ships pre-built shared libraries; build scripts can vendor the same artifacts used by the upstream project.

### 2. Low-Level Vosk FFI (`vosk-sys` crate)

- Exposes a direct `bindgen` layer over `vosk_api.h`.
- Useful when we need custom memory management, asynchronous execution, or to contribute additional bindings not covered by the safe crate.
- Requires manual unsafe wrappers; recommended only if the safe `vosk` crate lacks required APIs.

### 3. Kaldi Native Feature Extractor (`knf-rs` / `kaldi-native-fbank`)

- Provides Rust bindings to Kaldi's MFCC/filter-bank front-end.
- Useful for audio feature generation but does not include an HCLG decoder, lattice search, or symbol table management.
- Could serve as a building block for bespoke decoder logic, but would require significant additional effort (porting Kaldi's decoder or integrating with another engine).

### 4. Direct Kaldi C++ Bindings (cxx/autocxx)

- Possible to create targeted bindings into Kaldi's C++ libraries using `cxx` or `autocxx`.
- Prior community attempts report heavy build-tooling friction (Bazel/CMake hybrid, complex symbol visibility, and ABI churn).
- Maintenance burden is high; would require vendoring large portions of Kaldi and stabilizing C++ APIs for Rust consumption.

## Recommendation

- Prioritize the `vosk` crate for the initial Rust implementation: it delivers the closest feature parity with the current Python decoder while leaning on an actively maintained Kaldi-derived runtime.
- Prototype path:
  1. Package a proof-of-concept Rust service mirroring `ASR.decode_chunk` using Vosk's streaming API.
  2. Repackage existing Nabaztag models into Vosk format; validate WER against current Python pipeline.
  3. Benchmark latency and CPU usage on target hardware; ensure the shared `libvosk` footprint is acceptable.
  4. Integrate locale selection and grammar configuration in the Rust daemon.
- Keep `vosk-sys` as a contingency when low-level control or additional API surface is required.
- Treat `knf-rs` as a potential future enhancement if we choose to own the entire feature pipeline (e.g., experimenting with alternative decoders).
- Avoid committing to direct Kaldi C++ bindings unless Vosk proves insufficient, due to tooling complexity and long-term maintenance risk.

## Open Questions

- How much model conversion work is necessary to reuse the existing French and English acoustic/grammar assets with Vosk?
- What is the acceptable accuracy delta (WER) between `py-kaldi-asr` and the Rust/Vosk pipeline?
- Should we expose streaming hypotheses over the existing nabd protocol, or keep the interface aligned with `get_decoded_string` semantics?
- Do we need grammar-constrained decoding (e.g., keyword spotting) for parity, and does that map cleanly onto Vosk grammars?

Document authored October 5, 2025.
